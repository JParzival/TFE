wordcloud(words = df.bans$name, freq = df.bans$total, min.freq = 1, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))
# Ratio del más baneado
print("El porcentaje de baneo a Yasuo es de: ")
ratio.ban.yasuo <- df.bans$total[1]/sum(df.bans$total)
print(ratio.ban.yasuo)
set.seed(9999) # Para el mantenimiento del mismo patrón
wordcloud(words = df.bans$name, freq = df.bans$total, min.freq = 1, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))
dev.off
data.dragons.win <- cbind(data.games$t1_dragonKills, data.games$t2_dragonKills, data.games$winner)
colnames(data.dragons.win) <- c("KillsT1", "KillsT2", "Win")
head(data.dragons.win)
res.dragons.win <- cor(data.dragons.win, method = "spearman")
options(width = 100)
res.dragons.win.round <- round(res.dragons.win, 2)
corrplot(res.dragons.win.round, method="square", type = "upper", tl.srt = 0.7)
pdf("../imagenes/DrakesCorr.pdf")
corrplot(res.dragons.win.round, method="square", type = "upper", tl.srt = 0.7)
dev.off
mosaicplot(table(data.dragons.win[, 1], data.dragons.win[, 3]), main='Winrate por dragones matados, Equipo 1', shade=TRUE)
mosaicplot(table(data.dragons.win[, 2], data.dragons.win[, 3]), main='Winrate por dragones matados, Equipo 2', shade=TRUE)
pdf("../imagenes/Drakes MosaicPlot.pdf")
mosaicplot(table(data.dragons.win[, 1], data.dragons.win[, 3]), main='Winrate por dragones matados, Equipo 1', shade=TRUE)
mosaicplot(table(data.dragons.win[, 2], data.dragons.win[, 3]), main='Winrate por dragones matados, Equipo 2', shade=TRUE)
dev.off
# Lo que voy a hacer es contar por columnas, y luego sumo todas las columnas que he contado. Así obtengo el recuento final
# TEAM 1
cont.picks.t1.1 <- ddply(data.games,.(t1_champ1id),nrow)
cont.picks.t1.1 <- cont.picks.t1.1[order(cont.picks.t1.1$V1, decreasing = TRUE), ]
cont.picks.t1.2 <- ddply(data.games,.(t1_champ2id),nrow)
cont.picks.t1.2 <- cont.picks.t1.2[order(cont.picks.t1.2$V1, decreasing = TRUE), ]
cont.picks.t1.3 <- ddply(data.games,.(t1_champ3id),nrow)
cont.picks.t1.3 <- cont.picks.t1.3[order(cont.picks.t1.3$V1, decreasing = TRUE), ]
cont.picks.t1.4 <- ddply(data.games,.(t1_champ4id),nrow)
cont.picks.t1.4 <- cont.picks.t1.4[order(cont.picks.t1.4$V1, decreasing = TRUE), ]
cont.picks.t1.5 <- ddply(data.games,.(t1_champ5id),nrow)
cont.picks.t1.5 <- cont.picks.t1.5[order(cont.picks.t1.5$V1, decreasing = TRUE), ]
# TEAM 2
cont.picks.t2.1 <- ddply(data.games,.(t2_champ1id),nrow)
cont.picks.t2.1 <- cont.picks.t2.1[order(cont.picks.t2.1$V1, decreasing = TRUE), ]
cont.picks.t2.2 <- ddply(data.games,.(t2_champ2id),nrow)
cont.picks.t2.2 <- cont.picks.t2.2[order(cont.picks.t2.2$V1, decreasing = TRUE), ]
cont.picks.t2.3 <- ddply(data.games,.(t2_champ3id),nrow)
cont.picks.t2.3 <- cont.picks.t2.3[order(cont.picks.t2.3$V1, decreasing = TRUE), ]
cont.picks.t2.4 <- ddply(data.games,.(t2_champ4id),nrow)
cont.picks.t2.4 <- cont.picks.t2.4[order(cont.picks.t2.4$V1, decreasing = TRUE), ]
cont.picks.t2.5 <- ddply(data.games,.(t2_champ5id),nrow)
cont.picks.t2.5 <- cont.picks.t2.5[order(cont.picks.t2.5$V1, decreasing = TRUE), ]
# Ahora lo que tengo que hacer es sumar todas estas columnas de V1 según el valor de name...
df.picks <- left_join(cont.picks.t1.1, cont.picks.t1.2, by =c("t1_champ1id" = "t1_champ2id"))
df.picks <- left_join(df.picks, cont.picks.t1.3, by =c("t1_champ1id" = "t1_champ3id"))
df.picks <- left_join(df.picks, cont.picks.t1.4, by =c("t1_champ1id" = "t1_champ4id"))
df.picks <- left_join(df.picks, cont.picks.t1.5, by =c("t1_champ1id" = "t1_champ5id"))
df.picks <- left_join(df.picks, cont.picks.t2.1, by =c("t1_champ1id" = "t2_champ1id"))
df.picks <- left_join(df.picks, cont.picks.t2.2, by =c("t1_champ1id" = "t2_champ2id"))
df.picks <- left_join(df.picks, cont.picks.t2.3, by =c("t1_champ1id" = "t2_champ3id"))
df.picks <- left_join(df.picks, cont.picks.t2.4, by =c("t1_champ1id" = "t2_champ4id"))
df.picks <- left_join(df.picks, cont.picks.t2.5, by =c("t1_champ1id" = "t2_champ5id"))
df.picks$total <- rowSums( df.picks[,2:11] )
remove(cont.picks.t1.1)
remove(cont.picks.t1.2)
remove(cont.picks.t1.3)
remove(cont.picks.t1.4)
remove(cont.picks.t1.5)
remove(cont.picks.t2.1)
remove(cont.picks.t2.2)
remove(cont.picks.t2.3)
remove(cont.picks.t2.4)
remove(cont.picks.t2.5)
df.picks <- df.picks[order(df.picks$total, decreasing = TRUE), ]
df.picks <- df.picks[, -2:-11]
head(df.picks)
# Finalmente, junto con la tabla de data.champs para ponerles nombre...
df.picks <- left_join(df.picks, data.champs, by=c("t1_champ1id" = "id"))
df.picks <- df.picks[, -1]
head(df.picks)
set.seed(9998) # Para el mantenimiento del mismo patrón
wordcloud(words = df.picks$name, freq = df.picks$total, min.freq = 3000, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black")
)
# Ratio del más baneado
print("El porcentaje de pick de Thresh es de: ")
ratio.pick.thresh <- df.picks$total[1]/sum(df.picks$total)
print(ratio.pick.thresh)
pdf("../imagenes/wordcloudPicks.pdf")
set.seed(9998) # Para el mantenimiento del mismo patrón
wordcloud(words = df.picks$name, freq = df.picks$total, min.freq = 3000, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black")
)
dev.off
dataframe.winners.1 <- filter(data.games, winner == "1")
# En este dataframe, solo me interesan las columnas de los campeones elegidos por el equipo 1, por lo que solo me quedo con ellas:
dataframe.winners.1 <- dataframe.winners.1[, c(12, 15, 18, 21, 24)]
colnames(dataframe.winners.1) <- c("Pick1", "Pick2", "Pick3", "Pick4", "Pick5")
# Hacemos lo mismo con los ganadores del equipo 2
dataframe.winners.2 <- filter(data.games, winner == "2")
# En este dataframe, solo me interesan las columnas de los campeones elegidos por el equipo 1, por lo que solo me quedo con ellas:
dataframe.winners.2 <- dataframe.winners.2[, c(37, 40, 43, 46, 49)]
colnames(dataframe.winners.2) <- c("Pick1", "Pick2", "Pick3", "Pick4", "Pick5")
# Ahora los juntamos...
dataframe.winners <- rbind(dataframe.winners.1, dataframe.winners.2)
remove(dataframe.winners.1)
remove(dataframe.winners.2)
# Ahora voy a llevar todas las columnas a una:
dataframe.winners <- data.frame(all = c(dataframe.winners[,"Pick1"],
dataframe.winners[,"Pick2"],
dataframe.winners[,"Pick3"],
dataframe.winners[,"Pick4"],
dataframe.winners[,"Pick5"]))
head(dataframe.winners)
dataframe.winners <- left_join(dataframe.winners, data.champs, by=c("all" = "id"))
dataframe.winners <- dataframe.winners[, -1]
head(dataframe.winners)
# Ahora tenemos todo el dataframe en una única columna, donde solo nos queda ordenar y contar el número de ocurrencias:
dataframe.winners <- dataframe.winners[order(dataframe.winners)]
head(dataframe.winners)
# Contamos
cantidad <- as.data.frame(table(dataframe.winners))
cantidad <- cantidad[order(cantidad$Freq, decreasing = TRUE), ]
colnames(cantidad) <- c("name", "freq")
head(cantidad)
# Para hacer esto, voy a juntar los dos dataframes en uno solo, juntando por el valor del campeón (nombre), y una vez hecho esto podré restar entre mismas columnas
# No puedo hacer un join normal porque todos mis elementos de texto son factors, por eso lo reconvierto
cantidad <- data.frame(cantidad, stringsAsFactors = FALSE)
colnames(cantidad) <- c("name", "freq_win")
df.picks <- data.frame(df.picks, stringsAsFactors = FALSE)
colnames(df.picks) <- c("total_picks", "name")
dataframe.pick.win <- inner_join(cantidad, df.picks, by="name")
# Ahora que tengo los datos a mano, podemos hacer las divisiones:
dataframe.pick.win <- transform(dataframe.pick.win, ratio = dataframe.pick.win[, 2] / dataframe.pick.win[, 3])
dataframe.pick.win <- dataframe.pick.win[order(dataframe.pick.win$ratio, decreasing = TRUE), ]
head(dataframe.pick.win)
columna.wins <- data.games$winner
cantidad.wins <- as.data.frame(table(columna.wins))
colnames(cantidad.wins) <- c("winner", "frequency")
head(cantidad.wins)
# Si calculamos el ratio...
ratio.red <- cantidad.wins[2, 2] / (cantidad.wins[1, 2] + cantidad.wins[2, 2])
ratio.red
ratio.blue <- cantidad.wins[1, 2] / (cantidad.wins[1, 2] + cantidad.wins[2, 2])
ratio.blue
ratios_win <- c(ratio.blue, ratio.red)
barplot(ratios_win, main="Victorias por equipo", ylab="Equipo", col = c("Blue", "Red"))
pie(table(data.games$winner), main = "Victorias por equipo", col = c("Blue", "Red"))
pdf("../imagenes/Winrate Graphs.pdf")
barplot(ratios_win, main="Victorias por equipo", ylab="Equipo", col = c("Blue", "Red"))
pie(table(data.games$winner), main = "Victorias por equipo", col = c("Blue", "Red"))
dev.off
# Los datos de esto los tenemos en data.games. Para aclarar, vamos a hacer un dataset específico con los datos de los objetivos...
data.first.objectives <- data.games[, 6:11]
# Es importante remarcar que aquí hay 3 valores: 0 si nadie lo ha conseguido, 1 si lo ha conseguido el equipo azul y 2 si lo ha conseguido el equipo rojo.
head(data.first.objectives)
# Ahora mi objetivo es contar de cada una de las líneas lo que hay, y de aquí sacar conclusiones:
firstblood.qty <- as.data.frame(table(data.first.objectives[, 1]))
firsttower.qty <- as.data.frame(table(data.first.objectives[, 2]))
firstinhib.qty <- as.data.frame(table(data.first.objectives[, 3]))
firstbaron.qty <- as.data.frame(table(data.first.objectives[, 4]))
firstdragon.qty <- as.data.frame(table(data.first.objectives[, 5]))
firstherald.qty <- as.data.frame(table(data.first.objectives[, 6]))
# Ahora lo vemos bien en barplots...
array.firstblood <- c(firstblood.qty[1, 2],firstblood.qty[2, 2], firstblood.qty[3, 2])
barplot(array.firstblood, main="Partidas en las que los equipos hicieron Primera sangre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstblood.qty$Var1)
array.firsttower <- c(firsttower.qty[1, 2],firsttower.qty[2, 2], firsttower.qty[3, 2])
barplot(array.firsttower, main="Partidas en las que los equipos hicieron Primera torre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firsttower.qty$Var1)
array.firstinhib <- c(firstinhib.qty[1, 2],firstinhib.qty[2, 2], firstinhib.qty[3, 2])
barplot(array.firstinhib, main="Partidas en las que los equipos hicieron primer inhibidor", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstinhib.qty$Var1)
array.firstbaron <- c(firstbaron.qty[1, 2],firstbaron.qty[2, 2], firstbaron.qty[3, 2])
barplot(array.firstbaron, main="Partidas en las que los equipos hicieron primer barón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstbaron.qty$Var1)
array.firstdragon <- c(firstdragon.qty[1, 2],firstdragon.qty[2, 2], firstdragon.qty[3, 2])
barplot(array.firstdragon, main="Partidas en las que los equipos hicieron primer dragón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstdragon.qty$Var1)
array.firstherald <- c(firstherald.qty[1, 2],firstherald.qty[2, 2], firstherald.qty[3, 2])
barplot(array.firstherald, main="Partidas en las que los equipos hicieron el heraldo", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstherald.qty$Var1)
dataframe.firstObjective <- cbind(array.firstblood, array.firsttower, array.firstdragon, array.firstherald, array.firstinhib, array.firstbaron)
colnames(dataframe.firstObjective) <- c('FirstBlood', 'FirstTower', 'FirstDragon', 'FirstHerald', 'FirstInhib', 'FirstBaron')
colours = c("white","blue","red")
barplot(dataframe.firstObjective, main='Cantidad de primer objetivo de cada tipo conseguido por los equipos',ylab='Veces', xlab='Evento',beside = TRUE,
col=colours, ylim=c(0,max(dataframe.firstObjective)*1.3))
box()
pdf("../imagenes/Barplot Cronología Partida FO.pdf")
barplot(dataframe.firstObjective, main='Cantidad de primer objetivo de cada tipo conseguido por los equipos',ylab='Veces', xlab='Evento',beside = TRUE,
col=colours, ylim=c(0,max(dataframe.firstObjective)*1.3))
box()
dev.off
#data.games.factors <- lapply(data.games, function(x){as.factor(x)})
#reglas <- apriori(data.games.factors, parameter = list(support = 0.01, confidence = 0.5))
data.games.names <- inner_join(data.games, data.champs, by = c("t1_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ5id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ5id" = "id"))
champs.names <- data.games.names[,62:71]
colnames(champs.names) <- c("P1T1", "P2T1", "P3T1", "P4T1", "P5T1", "P1T2", "P2T2", "P3T2", "P4T2", "P5T2")
# Ahora paso todos los campeones a variables binarias. Esto hace que para todas las predicciones no tenga que usar distancias ni categorías entre ellos, lo que me permite que sean más justas.
vectors_champs <- dummy_cols(champs.names)
vectors_champs <- vectors_champs[, -1:-10]
# Ahora lo único que tengo que hacer es crear el dataset final para el machine learning, quitando aquellas variables que no deseo que estén (entre ellas el código de los campeones) y añadiendo esta codificación binaria que acabo de crear.
data.ml <- data.games[, c(-1, -2, -4, -13, -14, -16, -17, -19, -20, -22, -23, -25, -26, -38, -39, -41, -42, -44, -45, -47, -48)]
data.ml <- data.ml[, -9:-13]
data.ml <- data.ml[, -19:-25]
# Ahora hago lo mismo de antes para los nombres pero con los bans. Antes que nada, tengo que añadir None como la elección de ningún campeón para banear en el df de campeones.
df.tonto <- data.frame("None", as.integer(1000))
names(df.tonto) <- c("name", "id")
data.champs <- rbind(data.champs, df.tonto)
data.games[data.games=="-1"]<-1000
data.games.bans <- inner_join(data.games, data.champs, by = c("t1_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban5" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban5" = "id"))
champs.bans.names <- data.games.bans[,62:71]
colnames(champs.bans.names) <- c("B1T1", "B2T1", "B3T1", "B4T1", "B5T1", "B1T2", "B2T2", "B3T2", "B4T2", "B5T2")
vectors_champs.bans <- dummy_cols(champs.bans.names)
vectors_champs.bans <- vectors_champs.bans[, -1:-10]
# Finalmente, hago las últimas transformaciones y adiciones a data.ml para obtener el resultado final
data.ml <- data.ml[, -14:-18]
data.ml <- data.ml[, -19:-23]
data.ml <- cbind(data.ml, vectors_champs, vectors_champs.bans)
# Finalmente,hago una segunda matriz sin el resultado, que será la que centre y escale:
data.ml.centscal <- data.ml[, -2]
preObjeto <- preProcess(data.ml.centscal, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
data.ml.centscal <- predict(preObjeto, data.ml.centscal)
object_size(data.ml)
object_size(data.ml.centscal)
resultado.pca.ml <- PCA(data.ml.centscal, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca.ml)
eigenvalues.PCA.ml <- resultado.pca.ml$eig
head(eigenvalues.PCA.ml)
plotPCA.ml <- fviz_screeplot(resultado.pca.ml, ncp=60)
plot(plotPCA.ml)
pdf("../imagenes/PCATotal.pdf")
plot(plotPCA.ml)
dev.off
data.ml.campeones <- data.ml[, 19:2788]
matriz.sparse.campeones <- Matrix(data.ml.campeones, sparse = T)
data.ml.campeones <- data.ml[, 19:2788]
#matriz.sparse.campeones <- Matrix(data.ml.campeones, sparse = T)
resultado.pca.campeones.ml <- PCA(data.ml.campeones, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca.campeones.ml)
eigenvalues.PCA.campeones.ml <- resultado.pca.campeones.ml$eig
head(eigenvalues.PCA.campeones.ml)
plotPCA.campeones.ml <- fviz_screeplot(resultado.pca.campeones.ml, ncp=60)
plot(plotPCA.campeones.ml)
pdf("../imagenes/PCACampones.pdf")
plot(plotPCA.campeones.ml)
dev.off
data.ml.stats.centscal <- data.ml[, 1:18]
data.ml.stats.centscal <- data.ml.stats.centscal[, -2] #Quitamos el ganador
preObjeto.stats <- preProcess(data.ml.stats.centscal, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
data.ml.stats.centscal <- predict(preObjeto.stats, data.ml.stats.centscal)
resultado.pca.stats.ml <- PCA(data.ml.stats.centscal, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca.stats.ml)
eigenvalues.PCA.stats.ml <- resultado.pca.stats.ml$eig
head(eigenvalues.PCA.stats.ml)
plotPCA.stats.ml <- fviz_screeplot(resultado.pca.stats.ml, ncp=60)
plot(plotPCA.stats.ml)
pdf("../imagenes/PCAstatsML.pdf")
plot(plotPCA.stats.ml)
dev.off
conjuntoEntrenamiento <- sample(1:nrow(data.ml.stats.centscal), 45000)
resultados.perceptron <- data.frame(stringsAsFactors=FALSE)
# Ahora creamos un dataframe para guardar los resultados de este bucle
dataframe.resultados.1neu <- data.frame(Ent_1neu=numeric(),
Test_1neu=numeric())
for (i in 1:10)
{
partidas.1neu <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1, MaxNWts=10000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.1neu <- predict( partidas.1neu, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.1neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.1neu.class <- apply( partidas.prediccion.1neu, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_1neu<- sum( diag( table( partidas.prediccion.1neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.1neu <- predict( partidas.1neu, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.1neu.class <- apply( partidas.prediccion.test.1neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.1neu.class , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_1neu <- sum( diag( table( partidas.prediccion.test.1neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_1neu = acierto_ent_1neu,
Test_1neu= acierto_test_1neu)
dataframe.resultados.1neu <- rbind(dataframe.resultados.1neu, dataframe.pasada)
}
dataframe.resultados.1neu.soft <- data.frame(Ent_1neu_soft=numeric(),
Test_1neu_soft=numeric())
for (i in 1:10)
{
partidas.1neu.soft <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1, MaxNWts=10000, softmax = T )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.1neu.soft <- predict( partidas.1neu.soft, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.1neu.soft) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.1neu.class.soft <- apply( partidas.prediccion.1neu.soft, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_1neu.soft <- sum( diag( table( partidas.prediccion.1neu.class.soft, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.1neu.soft <- predict( partidas.1neu.soft, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.1neu.class.soft <- apply( partidas.prediccion.test.1neu.soft, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.1neu.class.soft , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_1neu.soft <- sum( diag( table( partidas.prediccion.test.1neu.class.soft, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_1neu_soft = acierto_ent_1neu.soft,
Test_1neu_soft= acierto_test_1neu.soft)
dataframe.resultados.1neu.soft <- rbind(dataframe.resultados.1neu.soft, dataframe.pasada)
}
dataframe.resultados.2neu <- data.frame(Ent_2neu=numeric(),
Test_2neu=numeric())
for (i in 1:10)
{
partidas.2neu <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=2, MaxNWts=10000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.2neu <- predict( partidas.2neu, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.2neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.2neu.class <- apply( partidas.prediccion.2neu, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_2neu<- sum( diag( table( partidas.prediccion.2neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.2neu <- predict( partidas.2neu, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.2neu.class <- apply( partidas.prediccion.test.2neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.2neu.class , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_2neu <- sum( diag( table( partidas.prediccion.test.2neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_2neu = acierto_ent_2neu,
Test_2neu= acierto_test_2neu)
dataframe.resultados.2neu <- rbind(dataframe.resultados.2neu, dataframe.pasada)
}
dataframe.resultados.2neu.soft <- data.frame(Ent_2neu_soft=numeric(),
Test_2neu_soft=numeric())
for (i in 1:10)
{
partidas.2neu.soft <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=2, MaxNWts=10000, softmax = T )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.2neu.soft <- predict( partidas.2neu.soft, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.2neu.soft) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.2neu.class.soft <- apply( partidas.prediccion.2neu.soft, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_2neu.soft <- sum( diag( table( partidas.prediccion.2neu.class.soft, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.2neu.soft <- predict( partidas.2neu.soft, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.2neu.class.soft <- apply( partidas.prediccion.test.2neu.soft, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.2neu.class.soft , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_2neu.soft <- sum( diag( table( partidas.prediccion.test.2neu.class.soft, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_2neu_soft = acierto_ent_2neu.soft,
Test_2neu_soft= acierto_test_2neu.soft)
dataframe.resultados.2neu.soft <- rbind(dataframe.resultados.2neu.soft, dataframe.pasada)
}
dataframe.resultados.3neu <- data.frame(Ent_3neu=numeric(),
Test_3neu=numeric())
for (i in 1:10)
{
partidas.3neu <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=3, MaxNWts=10000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.3neu <- predict( partidas.2neu, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.3neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.3neu.class <- apply( partidas.prediccion.3neu, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_3neu<- sum( diag( table( partidas.prediccion.3neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.3neu <- predict( partidas.3neu, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.3neu.class <- apply( partidas.prediccion.test.3neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.3neu.class , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_3neu <- sum( diag( table( partidas.prediccion.test.3neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_3neu = acierto_ent_3neu,
Test_3neu= acierto_test_3neu)
dataframe.resultados.3neu <- rbind(dataframe.resultados.3neu, dataframe.pasada)
}
dataframe.resultados.3neu.soft <- data.frame(Ent_3neu_soft=numeric(),
Test_3neu_soft=numeric())
for (i in 1:10)
{
partidas.3neu.soft <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=3, MaxNWts=10000, softmax = T )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.3neu.soft <- predict( partidas.3neu.soft, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.3neu.soft) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.3neu.class.soft <- apply( partidas.prediccion.3neu.soft, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_3neu.soft <- sum( diag( table( partidas.prediccion.3neu.class.soft, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.3neu.soft <- predict( partidas.3neu.soft, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.3neu.class.soft <- apply( partidas.prediccion.test.3neu.soft, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.3neu.class.soft , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_3neu.soft <- sum( diag( table( partidas.prediccion.test.3neu.class.soft, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_3neu_soft = acierto_ent_3neu.soft,
Test_3neu_soft= acierto_test_3neu.soft)
dataframe.resultados.3neu.soft <- rbind(dataframe.resultados.3neu.soft, dataframe.pasada)
}
dataframe.resultados.perceptron.stats <- cbind(dataframe.resultados.1neu,
dataframe.resultados.1neu.soft,
dataframe.resultados.2neu,
dataframe.resultados.2neu.soft,
dataframe.resultados.3neu,
dataframe.resultados.3neu.soft)
remove(dataframe.resultados.1neu)
remove(dataframe.resultados.1neu.soft)
remove(dataframe.resultados.2neu)
remove(dataframe.resultados.2neu.soft)
remove(dataframe.resultados.3neu)
remove(dataframe.resultados.3neu.soft)
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), 1:2])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu_soft, decreasing = TRUE), 3:4])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_2neu, decreasing = TRUE), 5:6])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_2neu_soft, decreasing = TRUE), 7:8])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu, decreasing = TRUE), 9:10])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu_soft, decreasing = TRUE), 11:12])
k <- round(sqrt(nrow(data.ml.stats.centscal)), 0)
conjuntoEntrenamiento <- data.ml.stats.centscal[1:45000, ]
conjuntoTest <- data.ml.stats.centscal[45001 : nrow(data.ml.stats.centscal), ] # Utilizo por supuesto la matriz de centrado y escalado
etiquetasEntrenamiento <- data.ml[1:45000, 2]
etiquetasTest <- data.ml[45001:nrow(data.ml.stats.centscal), 2]
prediccion.knn.227 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
k = 227)
head(prediccion.knn.227)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.227,
prop.chisq = FALSE)
prediccion.knn.150 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 150)
head(prediccion.knn.150)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.150,
prop.chisq = FALSE)
prediccion.knn.350 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 350)
head(prediccion.knn.350)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.350,
prop.chisq = FALSE)
data.ml.rf <-  data.ml[, 1:18]
data.ml.rf <- data.ml.rf[, -2] # Me quedo solo con la parte de stats y sin el ganador
model <- randomForest(as.factor(data.ml[, 2]) ~ ., data = data.ml.rf, importance = TRUE, ntree = 300)
model
plot(model, main="Random Forest - Solo Stats")
varImpPlot(model, main = "Random Forest (Stats) - MDA y Gini") # Gracias a importance = true
pdf("../imagenes/RandomForest_FT.pdf")
plot(model, main="Random Forest - Solo Stats")
varImpPlot(model, main = "Random Forest (Stats) - MDA y Gini")
dev.off
result <- rfcv(data.ml.rf, as.factor(data.ml[, 2]), cv.fold=10)
head(result)
modelo.svm <- svm(data.ml.stats.centscal, as.factor(data.ml[, 2]), kernel = "linear") # Al poner los grupos como factor, estoy consiguiendo que no sean continuos para el modelo, sino "discretos", ya que los factor no son valores que puedan ser continuos. Con esto consigo una clasificación.
summary(modelo.svm)
prediccion <- predict(modelo.svm, data.ml.stats.centscal)
head(prediccion)
matriz.conf <- table(prediccion, data.ml[, 2])
matriz.conf
sum(diag(matriz.conf))/nrow(data.ml)
modelo_svm.radial <- svm(data.ml.stats.centscal, as.factor(data.ml[, 2]), kernel="radial")
summary(modelo_svm.radial)
prediccion.radial <- predict(modelo_svm.radial, data.ml.stats.centscal)
head(prediccion.radial)
matriz.conf.radial <- table(prediccion.radial, data.ml[, 2])
matriz.conf.radial
sum(diag(matriz.conf.radial))/nrow(data.ml)
datos.kmeans <- data.ml[1:nrow(data.ml)]
datos.kmeans <- data.ml[1:nrow(data.ml), ]
clusters <- kmeans(datos.kmeans, centers = 2) #Dos centros, uno por vencedor
clusters$centers
clusters$cluster
# Ahora sacamos las plots
#Esta representación es sobre los dos ejes principales (componentes) que más explicación dan
clusplot(datos.kmeans, clusters$cluster, color = T, main = "Representación de las 51490 partidas en 2D - Función Clusplot", xlab = "Componente 1", ylab = "Componente 2")
pdf("../imagenes/resultados_kmeans.pdf")
clusplot(datos.kmeans, clusters$cluster, color = T, main = "Representación de las 51490 partidas en 2D - Función Clusplot", xlab = "Componente 1", ylab = "Componente 2")
plotcluster(datos.kmeans, clusters$cluster)
dev.off
#Usamos la matriz de centrado y escalado para que cada coordenada represente el mismo grado de diferencia
d <- dist(data.ml.stats.centscal[1:75, ], method = "euclidean")
cluster.jerarquico <- hclust(d, method = "complete" )
plot(cluster.jerarquico, cex = 0.5, hang = -1, main="Dendrograma 75 primeras partidas")
pdf("../imagenes/clusterJerárquico.pdf")
plot(cluster.jerarquico, cex = 0.5, hang = -1, main="Dendrograma 75 primeras partidas")
dev.off()
#Usamos la matriz de centrado y escalado para que cada coordenada represente el mismo grado de diferencia
d <- dist(data.ml.stats.centscal[1:65, ], method = "euclidean")
cluster.jerarquico <- hclust(d, method = "complete" )
plot(cluster.jerarquico, cex = 0.5, hang = -1, main="Dendrograma 75 primeras partidas")
#Usamos la matriz de centrado y escalado para que cada coordenada represente el mismo grado de diferencia
d <- dist(data.ml.stats.centscal[1:60, ], method = "euclidean")
cluster.jerarquico <- hclust(d, method = "complete" )
plot(cluster.jerarquico, cex = 0.5, hang = -1, main="Dendrograma 75 primeras partidas")
pdf("../imagenes/clusterJerárquico.pdf")
plot(cluster.jerarquico, cex = 0.5, hang = -1, main="Dendrograma 60 primeras partidas")
dev.off()
