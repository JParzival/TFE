df.picks <- df.picks[, -1]
head(df.picks)
set.seed(9998) # Para el mantenimiento del mismo patrón
wordcloud(words = df.picks$name, freq = df.picks$total, min.freq = 3000, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))
# Ratio del más baneado
print("El porcentaje de pick de Thresh es de: ")
ratio.pick.thresh <- df.picks$total[1]/sum(df.picks$total)
print(ratio.pick.thresh)
dataframe.winners.1 <- filter(data.games, winner == "1")
# En este dataframe, solo me interesan las columnas de los campeones elegidos por el equipo 1, por lo que solo me quedo con ellas:
dataframe.winners.1 <- dataframe.winners.1[, c(12, 15, 18, 21, 24)]
colnames(dataframe.winners.1) <- c("Pick1", "Pick2", "Pick3", "Pick4", "Pick5")
# Hacemos lo mismo con los ganadores del equipo 2
dataframe.winners.2 <- filter(data.games, winner == "2")
# En este dataframe, solo me interesan las columnas de los campeones elegidos por el equipo 1, por lo que solo me quedo con ellas:
dataframe.winners.2 <- dataframe.winners.2[, c(37, 40, 43, 46, 49)]
colnames(dataframe.winners.2) <- c("Pick1", "Pick2", "Pick3", "Pick4", "Pick5")
# Ahora los juntamos...
dataframe.winners <- rbind(dataframe.winners.1, dataframe.winners.2)
remove(dataframe.winners.1)
remove(dataframe.winners.2)
# Ahora voy a llevar todas las columnas a una:
dataframe.winners <- data.frame(all = c(dataframe.winners[,"Pick1"],
dataframe.winners[,"Pick2"],
dataframe.winners[,"Pick3"],
dataframe.winners[,"Pick4"],
dataframe.winners[,"Pick5"]))
head(dataframe.winners)
dataframe.winners <- left_join(dataframe.winners, data.champs, by=c("all" = "id"))
dataframe.winners <- dataframe.winners[, -1]
head(dataframe.winners)
# Ahora tenemos todo el dataframe en una única columna, donde solo nos queda ordenar y contar el número de ocurrencias:
dataframe.winners <- dataframe.winners[order(dataframe.winners)]
head(dataframe.winners)
# Contamos
cantidad <- as.data.frame(table(dataframe.winners))
cantidad <- cantidad[order(cantidad$Freq, decreasing = TRUE), ]
colnames(cantidad) <- c("name", "freq")
head(cantidad)
# Para hacer esto, voy a juntar los dos dataframes en uno solo, juntando por el valor del campeón (nombre), y una vez hecho esto podré restar entre mismas columnas
# No puedo hacer un join normal porque todos mis elementos de texto son factors, por eso lo reconvierto
cantidad <- data.frame(cantidad, stringsAsFactors = FALSE)
colnames(cantidad) <- c("name", "freq_win")
df.picks <- data.frame(df.picks, stringsAsFactors = FALSE)
colnames(df.picks) <- c("total_picks", "name")
dataframe.pick.win <- inner_join(cantidad, df.picks, by="name")
# Ahora que tengo los datos a mano, podemos hacer las divisiones:
dataframe.pick.win <- transform(dataframe.pick.win, ratio = dataframe.pick.win[, 2] / dataframe.pick.win[, 3])
dataframe.pick.win <- dataframe.pick.win[order(dataframe.pick.win$ratio, decreasing = TRUE), ]
head(dataframe.pick.win)
columna.wins <- data.games$winner
cantidad.wins <- as.data.frame(table(columna.wins))
colnames(cantidad.wins) <- c("winner", "frequency")
head(cantidad.wins)
# Si calculamos el ratio...
ratio.red <- cantidad.wins[2, 2] / (cantidad.wins[1, 2] + cantidad.wins[2, 2])
ratio.red
ratio.blue <- cantidad.wins[1, 2] / (cantidad.wins[1, 2] + cantidad.wins[2, 2])
ratio.blue
ratios_win <- c(ratio.blue, ratio.red)
barplot(ratios_win, main="Victorias por equipo", ylab="Equipo", col = c("Blue", "Red"))
# Los datos de esto los tenemos en data.games. Para aclarar, vamos a hacer un dataset específico con los datos de los objetivos...
data.first.objectives <- data.games[, 6:11]
# Es importante remarcar que aquí hay 3 valores: 0 si nadie lo ha conseguido, 1 si lo ha conseguido el equipo azul y 2 si lo ha conseguido el equipo rojo.
head(data.first.objectives)
# Ahora mi objetivo es contar de cada una de las líneas lo que hay, y de aquí sacar conclusiones:
firstblood.qty <- as.data.frame(table(data.first.objectives[, 1]))
firsttower.qty <- as.data.frame(table(data.first.objectives[, 2]))
firstinhib.qty <- as.data.frame(table(data.first.objectives[, 3]))
firstbaron.qty <- as.data.frame(table(data.first.objectives[, 4]))
firstdragon.qty <- as.data.frame(table(data.first.objectives[, 5]))
firstherald.qty <- as.data.frame(table(data.first.objectives[, 6]))
# Ahora lo vemos bien en barplots...
array.firstblood <- c(firstblood.qty[1, 2],firstblood.qty[2, 2], firstblood.qty[3, 2])
barplot(array.firstblood, main="Partidas en las que los equipos hicieron Primera sangre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstblood.qty$Var1)
array.firsttower <- c(firsttower.qty[1, 2],firsttower.qty[2, 2], firsttower.qty[3, 2])
barplot(array.firsttower, main="Partidas en las que los equipos hicieron Primera torre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firsttower.qty$Var1)
array.firstinhib <- c(firstinhib.qty[1, 2],firstinhib.qty[2, 2], firstinhib.qty[3, 2])
barplot(array.firstinhib, main="Partidas en las que los equipos hicieron primer inhibidor", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstinhib.qty$Var1)
array.firstbaron <- c(firstbaron.qty[1, 2],firstbaron.qty[2, 2], firstbaron.qty[3, 2])
barplot(array.firstbaron, main="Partidas en las que los equipos hicieron primer barón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstbaron.qty$Var1)
array.firstdragon <- c(firstdragon.qty[1, 2],firstdragon.qty[2, 2], firstdragon.qty[3, 2])
barplot(array.firstdragon, main="Partidas en las que los equipos hicieron primer dragón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstdragon.qty$Var1)
array.firstherald <- c(firstherald.qty[1, 2],firstherald.qty[2, 2], firstherald.qty[3, 2])
barplot(array.firstherald, main="Partidas en las que los equipos hicieron el heraldo", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstherald.qty$Var1)
dataframe.firstObjective <- cbind(array.firstblood, array.firsttower, array.firstdragon, array.firstherald, array.firstinhib, array.firstbaron)
colnames(dataframe.firstObjective) <- c('FirstBlood', 'FirstTower', 'FirstDragon', 'FirstHerald', 'FirstInhib', 'FirstBaron')
colours = c("white","blue","red")
barplot(dataframe.firstObjective, main='Cantidad de primer objetivo de cada tipo conseguido por los equipos',ylab='Veces', xlab='Evento',beside = TRUE,
col=colours, ylim=c(0,max(dataframe.firstObjective)*1.3))
# to add a box around the plot
box()
#data.games.factors <- lapply(data.games, function(x){as.factor(x)})
#reglas <- apriori(data.games.factors, parameter = list(support = 0.01, confidence = 0.5))
data.games.names <- inner_join(data.games, data.champs, by = c("t1_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ5id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ5id" = "id"))
champs.names <- data.games.names[,62:71]
colnames(champs.names) <- c("P1T1", "P2T1", "P3T1", "P4T1", "P5T1", "P1T2", "P2T2", "P3T2", "P4T2", "P5T2")
# Ahora paso todos los campeones a variables binarias. Esto hace que para todas las predicciones no tenga que usar distancias ni categorías entre ellos, lo que me permite que sean más justas.
vectors_champs <- dummy_cols(champs.names)
vectors_champs <- vectors_champs[, -1:-10]
# Ahora lo único que tengo que hacer es crear el dataset final para el machine learning, quitando aquellas variables que no deseo que estén (entre ellas el código de los campeones) y añadiendo esta codificación binaria que acabo de crear.
data.ml <- data.games[, c(-1, -2, -4, -13, -14, -16, -17, -19, -20, -22, -23, -25, -26, -38, -39, -41, -42, -44, -45, -47, -48)]
data.ml <- data.ml[, -9:-13]
data.ml <- data.ml[, -19:-25]
# Ahora hago lo mismo de antes para los nombres pero con los bans. Antes que nada, tengo que añadir None como la elección de ningún campeón para banear en el df de campeones.
df.tonto <- data.frame("None", as.integer(1000))
names(df.tonto) <- c("name", "id")
data.champs <- rbind(data.champs, df.tonto)
data.games[data.games=="-1"]<-1000
data.games.bans <- inner_join(data.games, data.champs, by = c("t1_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban5" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban5" = "id"))
champs.bans.names <- data.games.bans[,62:71]
colnames(champs.bans.names) <- c("B1T1", "B2T1", "B3T1", "B4T1", "B5T1", "B1T2", "B2T2", "B3T2", "B4T2", "B5T2")
vectors_champs.bans <- dummy_cols(champs.bans.names)
vectors_champs.bans <- vectors_champs.bans[, -1:-10]
# Finalmente, hago las últimas transformaciones y adiciones a data.ml para obtener el resultado final
data.ml <- data.ml[, -14:-18]
data.ml <- data.ml[, -19:-23]
data.ml <- cbind(data.ml, vectors_champs, vectors_champs.bans)
# Finalmente,hago una segunda matriz sin el resultado, que será la que centre y escale:
data.ml.centscal <- data.ml[, -2]
preObjeto <- preProcess(data.ml.centscal, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
data.ml.centscal <- predict(preObjeto, data.ml.centscal)
object_size(data.ml)
object_size(data.ml.centscal)
resultado.pca.ml <- PCA(data.ml.centscal, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca.ml)
eigenvalues.PCA.ml <- resultado.pca.ml$eig
head(eigenvalues.PCA.ml)
plotPCA.ml <- fviz_screeplot(resultado.pca.ml, ncp=60)
plot(plotPCA.ml)
data.ml.campeones.centscal <- data.ml[, 19:2788]
preObjeto.campeones <- preProcess(data.ml.campeones.centscal, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
data.ml.campeones.centscal <- predict(preObjeto.campeones, data.ml.campeones.centscal)
resultado.pca.campeones.ml <- PCA(data.ml.campeones.centscal, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca.campeones.ml)
eigenvalues.PCA.campeones.ml <- resultado.pca.campeones.ml$eig
head(eigenvalues.PCA.campeones.ml)
plotPCA.campeones.ml <- fviz_screeplot(resultado.pca.campeones.ml, ncp=60)
plot(plotPCA.campeones.ml)
data.ml.stats.centscal <- data.ml[, 1:18]
data.ml.stats.centscal <- data.ml.stats.centscal[, -2] #Quitamos el ganador
preObjeto.stats <- preProcess(data.ml.stats.centscal, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
data.ml.stats.centscal <- predict(preObjeto.stats, data.ml.stats.centscal)
resultado.pca.stats.ml <- PCA(data.ml.stats.centscal, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca.stats.ml)
eigenvalues.PCA.stats.ml <- resultado.pca.stats.ml$eig
head(eigenvalues.PCA.stats.ml)
plotPCA.stats.ml <- fviz_screeplot(resultado.pca.stats.ml, ncp=60)
plot(plotPCA.stats.ml)
conjuntoEntrenamiento <- sample(1:nrow(data.ml.stats.centscal), 45000)
resultados.perceptron <- data.frame(stringsAsFactors=FALSE)
# Ahora creamos un dataframe para guardar los resultados de este bucle
dataframe.resultados.1neu <- data.frame(Ent_1neu=numeric(),
Test_1neu=numeric())
for (i in 1:10)
{
partidas.1neu <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1, MaxNWts=10000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.1neu <- predict( partidas.1neu, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.1neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.1neu.class <- apply( partidas.prediccion.1neu, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_1neu<- sum( diag( table( partidas.prediccion.1neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.1neu <- predict( partidas.1neu, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.1neu.class <- apply( partidas.prediccion.test.1neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.1neu.class , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_1neu <- sum( diag( table( partidas.prediccion.test.1neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_1neu = acierto_ent_1neu,
Test_1neu= acierto_test_1neu)
dataframe.resultados.1neu <- rbind(dataframe.resultados.1neu, dataframe.pasada)
}
dataframe.resultados.1neu.soft <- data.frame(Ent_1neu_soft=numeric(),
Test_1neu_soft=numeric())
for (i in 1:10)
{
partidas.1neu.soft <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1, MaxNWts=10000, softmax = T )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.1neu.soft <- predict( partidas.1neu.soft, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.1neu.soft) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.1neu.class.soft <- apply( partidas.prediccion.1neu.soft, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_1neu.soft <- sum( diag( table( partidas.prediccion.1neu.class.soft, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.1neu.soft <- predict( partidas.1neu.soft, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.1neu.class.soft <- apply( partidas.prediccion.test.1neu.soft, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.1neu.class.soft , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_1neu.soft <- sum( diag( table( partidas.prediccion.test.1neu.class.soft, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_1neu_soft = acierto_ent_1neu.soft,
Test_1neu_soft= acierto_test_1neu.soft)
dataframe.resultados.1neu.soft <- rbind(dataframe.resultados.1neu.soft, dataframe.pasada)
}
dataframe.resultados.2neu <- data.frame(Ent_2neu=numeric(),
Test_2neu=numeric())
for (i in 1:10)
{
partidas.2neu <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=2, MaxNWts=10000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.2neu <- predict( partidas.2neu, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.2neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.2neu.class <- apply( partidas.prediccion.2neu, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_2neu<- sum( diag( table( partidas.prediccion.2neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.2neu <- predict( partidas.2neu, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.2neu.class <- apply( partidas.prediccion.test.2neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.2neu.class , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_2neu <- sum( diag( table( partidas.prediccion.test.2neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_2neu = acierto_ent_2neu,
Test_2neu= acierto_test_2neu)
dataframe.resultados.2neu <- rbind(dataframe.resultados.2neu, dataframe.pasada)
}
dataframe.resultados.2neu.soft <- data.frame(Ent_2neu_soft=numeric(),
Test_2neu_soft=numeric())
for (i in 1:10)
{
partidas.2neu.soft <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=2, MaxNWts=10000, softmax = T )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.2neu.soft <- predict( partidas.2neu.soft, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.2neu.soft) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.2neu.class.soft <- apply( partidas.prediccion.2neu.soft, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_2neu.soft <- sum( diag( table( partidas.prediccion.2neu.class.soft, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.2neu.soft <- predict( partidas.2neu.soft, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.2neu.class.soft <- apply( partidas.prediccion.test.2neu.soft, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.2neu.class.soft , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_2neu.soft <- sum( diag( table( partidas.prediccion.test.2neu.class.soft, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_2neu_soft = acierto_ent_2neu.soft,
Test_2neu_soft= acierto_test_2neu.soft)
dataframe.resultados.2neu.soft <- rbind(dataframe.resultados.2neu.soft, dataframe.pasada)
}
dataframe.resultados.3neu <- data.frame(Ent_3neu=numeric(),
Test_3neu=numeric())
for (i in 1:10)
{
partidas.3neu <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=3, MaxNWts=10000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.3neu <- predict( partidas.2neu, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.3neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.3neu.class <- apply( partidas.prediccion.3neu, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_3neu<- sum( diag( table( partidas.prediccion.3neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.3neu <- predict( partidas.3neu, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.3neu.class <- apply( partidas.prediccion.test.3neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.3neu.class , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_3neu <- sum( diag( table( partidas.prediccion.test.3neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_3neu = acierto_ent_3neu,
Test_3neu= acierto_test_3neu)
dataframe.resultados.3neu <- rbind(dataframe.resultados.3neu, dataframe.pasada)
}
dataframe.resultados.3neu.soft <- data.frame(Ent_3neu_soft=numeric(),
Test_3neu_soft=numeric())
for (i in 1:10)
{
partidas.3neu.soft <- nnet( data.ml.stats.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=3, MaxNWts=10000, softmax = T )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.3neu.soft <- predict( partidas.3neu.soft, data.ml.stats.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.3neu.soft) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.3neu.class.soft <- apply( partidas.prediccion.3neu.soft, MARGIN=1, FUN='which.is.max')
#Calculo el acierto
acierto_ent_3neu.soft <- sum( diag( table( partidas.prediccion.3neu.class.soft, data.ml[conjuntoEntrenamiento, 2] ) ) )/length(conjuntoEntrenamiento)
###### TEST
partidas.prediccion.test.3neu.soft <- predict( partidas.3neu.soft, data.ml.stats.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.3neu.class.soft <- apply( partidas.prediccion.test.3neu.soft, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.3neu.class.soft , data.ml[-conjuntoEntrenamiento, 2] )
acierto_test_3neu.soft <- sum( diag( table( partidas.prediccion.test.3neu.class.soft, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(nrow(data.ml.stats.centscal) - length(conjuntoEntrenamiento))
dataframe.pasada <- data.frame(Ent_3neu_soft = acierto_ent_3neu.soft,
Test_3neu_soft= acierto_test_3neu.soft)
dataframe.resultados.3neu.soft <- rbind(dataframe.resultados.3neu.soft, dataframe.pasada)
}
dataframe.resultados.perceptron.stats <- cbind(dataframe.resultados.1neu,
dataframe.resultados.1neu.soft,
dataframe.resultados.2neu,
dataframe.resultados.2neu.soft,
dataframe.resultados.3neu,
dataframe.resultados.3neu.soft)
remove(dataframe.resultados.1neu)
remove(dataframe.resultados.1neu.soft)
remove(dataframe.resultados.2neu)
remove(dataframe.resultados.2neu.soft)
remove(dataframe.resultados.3neu)
remove(dataframe.resultados.3neu.soft)
k <- round(sqrt(nrow(data.ml.stats.centscal)), 0)
conjuntoEntrenamiento <- data.ml.stats.centscal[1:45000, ]
conjuntoTest <- data.ml.stats.centscal[45001 : nrow(data.ml.centscal), ] # Utilizo por supuesto la matriz de centrado y escalado
etiquetasEntrenamiento <- data.ml[1:45000, 2]
etiquetasTest <- data.ml[45001:nrow(data.ml.stats.centscal), ]
prediccion.knn.227 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 227)
prediccion.knn.227
CrossTable(x = etiquetasTest ,
y = prediccion.knn.227,
prop.chisq = FALSE)
length(etiquetasTest)
length(prediccion.knn.227)
nrow(data.ml.stats.centscal)
etiquetasTest <- data.ml[45001:nrow(data.ml.stats.centscal), ]
length(etiquetasTest)
conjuntoEntrenamiento <- data.ml.stats.centscal[1:45000, ]
conjuntoTest <- data.ml.stats.centscal[45001 : nrow(data.ml.stats.centscal), ] # Utilizo por supuesto la matriz de centrado y escalado
etiquetasEntrenamiento <- data.ml[1:45000, 2]
etiquetasTest <- data.ml[45001:nrow(data.ml.stats.centscal), ]
prediccion.knn.227 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 227)
head(prediccion.knn.227)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.227,
prop.chisq = FALSE)
prediccion.knn.227 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
k = 227)
head(prediccion.knn.227)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.227,
prop.chisq = FALSE)
conjuntoEntrenamiento <- data.ml.stats.centscal[1:45000, ]
conjuntoTest <- data.ml.stats.centscal[45001 : nrow(data.ml.stats.centscal), ] # Utilizo por supuesto la matriz de centrado y escalado
etiquetasEntrenamiento <- data.ml[1:45000, 2]
etiquetasTest <- data.ml[45001:nrow(data.ml.stats.centscal), 2]
conjuntoEntrenamiento <- data.ml.stats.centscal[1:45000, ]
conjuntoTest <- data.ml.stats.centscal[45001 : nrow(data.ml.stats.centscal), ] # Utilizo por supuesto la matriz de centrado y escalado
etiquetasEntrenamiento <- data.ml[1:45000, 2]
etiquetasTest <- data.ml[45001:nrow(data.ml.stats.centscal), 2]
prediccion.knn.227 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
k = 227)
head(prediccion.knn.227)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.227,
prop.chisq = FALSE)
prediccion.knn.150 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 150)
prediccion.knn.150
CrossTable(x = etiquetasTest ,
y = prediccion.knn.150,
prop.chisq = FALSE)
prediccion.knn.350 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 350)
prediccion.knn.350
prediccion.knn.350 <- knn(train = conjuntoEntrenamiento,
test = conjuntoTest,
cl = etiquetasEntrenamiento,
prob = TRUE,
k = 350)
head(prediccion.knn.350)
CrossTable(x = etiquetasTest ,
y = prediccion.knn.350,
prop.chisq = FALSE)
model <- randomForest(as.factor(data.ml[, 2]) ~ ., data = data.ml[, 1:18], importance = TRUE, ntree = 300)
install.packages("randomforest")
install.packages("randomForest")
library("randomForest")
model <- randomForest(as.factor(data.ml[, 2]) ~ ., data = data.ml[, 1:18], importance = TRUE, ntree = 300)
model
plot(model, main="Random Forest - Solo Stats")
varImpPlot(model, main = "Random Forest (Stats) - MDA y Gini") # Gracias a importance = true
data.ml.rf <-  data.ml[, 1:18]
data.ml.rf <- data.ml.rf[, -2]
data.ml.rf <-  data.ml[, 1:18]
data.ml.rf <- data.ml.rf[, -2]
model <- randomForest(as.factor(data.ml[, 2]) ~ ., data = data.ml.rf, importance = TRUE, ntree = 300)
model
plot(model, main="Random Forest - Solo Stats")
varImpPlot(model, main = "Random Forest (Stats) - MDA y Gini") # Gracias a importance = true
result <- rfcv(data.ml[ , 1:18], as.factor(data.ml[, 2]), cv.fold=10)
result <- rfcv(data.ml.rf, as.factor(data.ml[, 2]), cv.fold=10)
modelo.svm <- svm(data.ml.stats.centscal, as.factor(data.ml[, 2]), kernel = "linear") # Al poner los grupos como factor, estoy consiguiendo que no sean continuos para el modelo, sino "discretos", ya que los factor no son valores que puedan ser continuos. Con esto consigo una clasificación.
install.packages("e1071")
library("e1071")
modelo.svm <- svm(data.ml.stats.centscal, as.factor(data.ml[, 2]), kernel = "linear") # Al poner los grupos como factor, estoy consiguiendo que no sean continuos para el modelo, sino "discretos", ya que los factor no son valores que puedan ser continuos. Con esto consigo una clasificación.
summary(modelo.svm)
prediccion <- predict(modelo.svm, data.ml.stats.centscal)
prediccion
matriz.conf <- table(prediccion, data.ml[, 2])
matriz.conf
sum(diag(matriz.conf))/nrow(data.ml)
modelo_svm.radial <- svm(data.ml.stats.centscal, as.factor(data.ml[, 2]), kernel="radial")
summary(modelo_svm.radial)
prediccion.radial <- predict(modelo_svm.radial, data.ml.stats.centscal)
prediccion.radial
matriz.conf.radial <- table(prediccion.radial, data.ml[, 2])
matriz.conf.radial
sum(diag(matriz.conf.radial))/nrow(data.ml)
View(data.ml)
View(data.ml)
View(data.ml.stats.centscal)
View(data.ml.stats.centscal)
View(dataframe.resultados.perceptron.stats)
View(dataframe.resultados.perceptron.stats)
apply( dataframe.resultados.perceptron.stats[ , 2], MARGIN=1, FUN='which.is.max')
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu), ]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), ]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), 1:2]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu_soft, decreasing = TRUE), 3:4]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), 1:2]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu_soft, decreasing = TRUE), 3:4]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_2neu, decreasing = TRUE), 5:6]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_2neu_soft, decreasing = TRUE), 7:8]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu, decreasing = TRUE), 9:10]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_4neu_soft, decreasing = TRUE), 11:12]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu_soft, decreasing = TRUE), 11:12]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), 1:2]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu_soft, decreasing = TRUE), 3:4]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_2neu, decreasing = TRUE), 5:6]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_2neu_soft, decreasing = TRUE), 7:8]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu, decreasing = TRUE), 9:10]
dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu_soft, decreasing = TRUE), 11:12]
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), 1:2])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_1neu, decreasing = TRUE), 1:2])
head(dataframe.resultados.perceptron.stats[order(dataframe.resultados.perceptron.stats$Test_3neu_soft, decreasing = TRUE), 11:12])
plot(model, main="Random Forest - Solo Stats")
varImpPlot(model, main = "Random Forest (Stats) - MDA y Gini") # Gracias a importance = true
pie(table(data.games$winner))
pie(table(data.games$winner), main = "Victorias por equipo", col = c("Blue", "Red"))
install.packages("aplpack")
View(data.games)
View(data.games)
muestra_partidas<-data.games[sample(1:dim(data.games)[1],size=32,replace=F), ]
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
library("aplpack")
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
muestra_partidas<-data.games[sample(1:dim(data.games)[1],size=16,replace=F), ]
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
muestra.chernoff <- sample(2 : dim(data.games)[1], size=16, replace=F)
muestra_partidas<-data.games[muestra.chernoff, ]
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
help ("sample")
muestra.chernoff <- data.games[sample_n(data.games, size = 16, replace = FALSE,)]
muestra.chernoff <- data.games[sample_n(data.games, size = 16, replace = FALSE)]
muestra.chernoff <- data.games[sample_n(table(data.games), size = 16, replace = FALSE)]
muestra.chernoff <- data.games[1:16, ]
muestra_partidas<-data.games[muestra.chernoff, ]
muestra_partidas<-data.games[1:16, ]
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
muestra_partidas<-data.games[1:16, 6:10]
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
muestra_partidas<-data.games[1:16, 6:15]
faces(muestra_partidas[1:4],face.type=1,labels=data.games$winner)
faces(muestra_partidas[1:9],face.type=1,labels=data.games$winner)
faces(muestra_partidas[1:7],face.type=1,labels=data.games$winner)
faces(muestra_partidas[1:6],face.type=1,labels=data.games$winner)
muestra_partidas<-data.games[1:16, 6:15]
faces(muestra_partidas[1:6],face.type=1,labels=data.games$winner[1:16, ])
faces(muestra_partidas[1:6],face.type=1,labels=data.games[1:16, 5])
faces(muestra_partidas[1:7],face.type=1,labels=data.games[1:16, 5])
faces(muestra_partidas[1:6],face.type=1,labels=data.games[1:16, 5])
data.games[1:16, 6:15]
muestra_partidas<-data.games[1:16, 6:11]
faces(muestra_partidas[1:6],face.type=1,labels=data.games[1:16, 5])
muestra_partidas <- data.games[1:16, 27:31]
muestra_partidas <- cbind(muestra_partidas, data.games[1:16, 52:56])
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5])
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas")
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", print.info = TRUE)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 0.7)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 0.9)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 0.5)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 0.1)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 0.9)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 1)
faces(muestra_partidas[1:10], face.type=1,labels=data.games[1:16, 5], main = "Diferencias entre partidas", scale = TRUE, cex = 1.5)
