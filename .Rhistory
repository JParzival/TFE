# Es importante remarcar que aquí hay 3 valores: 0 si nadie lo ha conseguido, 1 si lo ha conseguido el equipo azul y 2 si lo ha conseguido el equipo rojo.
head(data.first.objectives)
# Ahora mi objetivo es contar de cada una de las líneas lo que hay, y de aquí sacar conclusiones:
firstblood.qty <- as.data.frame(table(data.first.objectives[, 1]))
firsttower.qty <- as.data.frame(table(data.first.objectives[, 2]))
firstinhib.qty <- as.data.frame(table(data.first.objectives[, 3]))
firstbaron.qty <- as.data.frame(table(data.first.objectives[, 4]))
firstdragon.qty <- as.data.frame(table(data.first.objectives[, 5]))
firstherald.qty <- as.data.frame(table(data.first.objectives[, 6]))
# Ahora lo vemos bien en barplots...
array.firstblood <- c(firstblood.qty[1, 2],firstblood.qty[2, 2], firstblood.qty[3, 2])
barplot(array.firstblood, main="Partidas en las que los equipos hicieron Primera sangre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstblood.qty$Var1)
array.firsttower <- c(firsttower.qty[1, 2],firsttower.qty[2, 2], firsttower.qty[3, 2])
barplot(array.firsttower, main="Partidas en las que los equipos hicieron Primera torre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firsttower.qty$Var1)
array.firstinhib <- c(firstinhib.qty[1, 2],firstinhib.qty[2, 2], firstinhib.qty[3, 2])
barplot(array.firstinhib, main="Partidas en las que los equipos hicieron primer inhibidor", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstinhib.qty$Var1)
array.firstbaron <- c(firstbaron.qty[1, 2],firstbaron.qty[2, 2], firstbaron.qty[3, 2])
barplot(array.firstbaron, main="Partidas en las que los equipos hicieron primer barón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstbaron.qty$Var1)
array.firstdragon <- c(firstdragon.qty[1, 2],firstdragon.qty[2, 2], firstdragon.qty[3, 2])
barplot(array.firstdragon, main="Partidas en las que los equipos hicieron primer dragón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstdragon.qty$Var1)
array.firstherald <- c(firstherald.qty[1, 2],firstherald.qty[2, 2], firstherald.qty[3, 2])
barplot(array.firstherald, main="Partidas en las que los equipos hicieron el heraldo", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstherald.qty$Var1)
dataframe.firstObjective <- cbind(array.firstblood, array.firsttower, array.firstdragon, array.firstherald, array.firstinhib, array.firstbaron)
colnames(dataframe.firstObjective) <- c('FirstBlood', 'FirstTower', 'FirstDragon', 'FirstHerald', 'FirstInhib', 'FirstBaron')
colours = c("white","blue","red")
barplot(dataframe.firstObjective, main='Cantidad de primer objetivo de cada tipo conseguido por los equipos',ylab='Veces', xlab='Evento',beside = TRUE,
col=colours, ylim=c(0,max(dataframe.firstObjective)*1.3))
# to add a box around the plot
box()
#data.games.factors <- lapply(data.games, function(x){as.factor(x)})
#reglas <- apriori(data.games.factors, parameter = list(support = 0.01, confidence = 0.5))
data.games.names <- inner_join(data.games, data.champs, by = c("t1_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ5id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ5id" = "id"))
champs.names <- data.games.names[,62:71]
colnames(champs.names) <- c("P1T1", "P2T1", "P3T1", "P4T1", "P5T1", "P1T2", "P2T2", "P3T2", "P4T2", "P5T2")
# Ahora paso todos los campeones a variables binarias. Esto hace que para todas las predicciones no tenga que usar distancias ni categorías entre ellos, lo que me permite que sean más justas.
vectors_champs <- dummy_cols(champs.names)
vectors_champs <- vectors_champs[, -1:-10]
# Ahora lo único que tengo que hacer es crear el dataset final para el machine learning, quitando aquellas variables que no deseo que estén (entre ellas el código de los campeones) y añadiendo esta codificación binaria que acabo de crear.
data.ml <- data.games[, c(-1, -2, -4, -13, -14, -16, -17, -19, -20, -22, -23, -25, -26, -38, -39, -41, -42, -44, -45, -47, -48)]
data.ml <- data.ml[, -9:-13]
data.ml <- data.ml[, -19:-25]
# Ahora hago lo mismo de antes para los nombres pero con los bans. Antes que nada, tengo que añadir None como la elección de ningún campeón para banear en el df de campeones.
df.tonto <- data.frame("None", as.integer(1000))
names(df.tonto) <- c("name", "id")
data.champs <- rbind(data.champs, df.tonto)
data.games[data.games=="-1"]<-1000
data.games.bans <- inner_join(data.games, data.champs, by = c("t1_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban5" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban5" = "id"))
champs.bans.names <- data.games.bans[,62:71]
colnames(champs.names) <- c("B1T1", "B2T1", "B3T1", "B4T1", "B5T1", "B1T2", "B2T2", "B3T2", "B4T2", "B5T2")
vectors_champs.bans <- dummy_cols(champs.bans.names)
vectors_champs.bans <- vectors_champs.bans[, -1:-10]
# Finalmente, hago las últimas transformaciones y adiciones a data.ml para obtener el resultado final
data.ml <- data.ml[, -14:-18]
data.ml <- data.ml[, -19:-23]
data.ml <- cbind(data.ml, vectors_champs, vectors_champs.bans)
# Ahora tenemos todo junto. Limpio los df que han quedado como auxiliares y procedemos al centrado y escalado:
remove(vectors_champs.bans)
remove(vectors_champs)
remove(df.tonto)
colnames( data.ml )
colnames( data.ml[2000:2500] )
data.games.names <- inner_join(data.games, data.champs, by = c("t1_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ5id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ5id" = "id"))
champs.names <- data.games.names[,62:71]
colnames(champs.names) <- c("P1T1", "P2T1", "P3T1", "P4T1", "P5T1", "P1T2", "P2T2", "P3T2", "P4T2", "P5T2")
# Ahora paso todos los campeones a variables binarias. Esto hace que para todas las predicciones no tenga que usar distancias ni categorías entre ellos, lo que me permite que sean más justas.
vectors_champs <- dummy_cols(champs.names)
vectors_champs <- vectors_champs[, -1:-10]
# Ahora lo único que tengo que hacer es crear el dataset final para el machine learning, quitando aquellas variables que no deseo que estén (entre ellas el código de los campeones) y añadiendo esta codificación binaria que acabo de crear.
data.ml <- data.games[, c(-1, -2, -4, -13, -14, -16, -17, -19, -20, -22, -23, -25, -26, -38, -39, -41, -42, -44, -45, -47, -48)]
data.ml <- data.ml[, -9:-13]
data.ml <- data.ml[, -19:-25]
# Ahora hago lo mismo de antes para los nombres pero con los bans. Antes que nada, tengo que añadir None como la elección de ningún campeón para banear en el df de campeones.
df.tonto <- data.frame("None", as.integer(1000))
names(df.tonto) <- c("name", "id")
data.champs <- rbind(data.champs, df.tonto)
data.games[data.games=="-1"]<-1000
data.games.bans <- inner_join(data.games, data.champs, by = c("t1_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban5" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban5" = "id"))
champs.bans.names <- data.games.bans[,62:71]
colnames(champs.bans.names) <- c("B1T1", "B2T1", "B3T1", "B4T1", "B5T1", "B1T2", "B2T2", "B3T2", "B4T2", "B5T2")
vectors_champs.bans <- dummy_cols(champs.bans.names)
vectors_champs.bans <- vectors_champs.bans[, -1:-10]
# Finalmente, hago las últimas transformaciones y adiciones a data.ml para obtener el resultado final
data.ml <- data.ml[, -14:-18]
data.ml <- data.ml[, -19:-23]
data.ml <- cbind(data.ml, vectors_champs, vectors_champs.bans)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
#install.packages("dplyr")
#install.packages("pryr")
#install.packages("corrplot")
#install.packages("rjson")
#install.packages("plyr")
#install.packages("wordcloud")
#install.packages("ggplot2")
#install.packages("hexbin")
#install.packages("RColorBrewer")
#install.packages("FactoMineR")
#devtools::install_github("kassambara/factoextra")
#install.packages("factoextra")
#install.packages("arules")
#install.packages("arulesViz")
#install.packages("fastDummies")
library("corrplot")
library("dplyr")
library("pryr")
library("rjson")
library("plyr")
library("wordcloud")
library("ggplot2")
library("hexbin")
library("RColorBrewer")
library("FactoMineR")
library("factoextra")
require("arulesViz")
require("arules")
library("Matrix")
library("fastDummies")
data.games <- read.csv("../data/games.csv")
data.champs <- read.csv("../data/champs.csv")
lista.championInfo <- fromJSON(file = "../data/champion_info.json")
lista.championInfo2 <- fromJSON(file="../data/champion_info_2.json")
lista.summonerSpell <- fromJSON(file="../data/summoner_spell_info.json")
print("El tamaño de la tabla de games es de: ")
object_size(data.games) # Es un dataset de 433 MB
data.games[!complete.cases(data.games),]
print("Resumen de data.games")
summary(data.games) # Las únicas columnas interesantes son la 5 y la 6
# Ahora voy a hacer una tabla de games especial solo con las variables de las que calcularemos las correlaciones
# Game ID es una variable que no necesito para nada, por lo que la voy a eliminar:
data.games.corr <- data.games[, c(-1, -4)]
#head(data.games.corr)
data.games.corr <- data.games.corr[, -10:-24]
#head(data.games.corr)
data.games.corr <- data.games.corr[, -15:-34]
#head(data.games.corr)
data.games.corr <- data.games.corr[, -20:-24]
res.games <- cor(data.games.corr, method = "spearman")
options(width = 100)
res.games.round <- round(res.games, 2)
corrplot(res.games.round, method="circle", type = "upper")
resultado.pca <- PCA(data.games.corr, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca)
eigenvalues.PCA <- resultado.pca$eig
eigenvalues.PCA
plotPCA <- fviz_screeplot(resultado.pca, ncp=19, main="Barplot de explicación de varianza", ylab="Porcentaje de explicación", xlab="Dimensión")
plot(plotPCA)
head(resultado.pca$var$coord)
fviz_pca_var(resultado.pca)
fviz_pca_ind(resultado.pca)
# Lo que voy a hacer es contar por columnas, y luego sumo todas las columnas que he contado. Así obtengo el recuento final
# TEAM 1
cont.bans.t1.1 <- ddply(data.games,.(t1_ban1),nrow)
cont.bans.t1.1 <- cont.bans.t1.1[order(cont.bans.t1.1$V1, decreasing = TRUE), ]
cont.bans.t1.2 <- ddply(data.games,.(t1_ban2),nrow)
cont.bans.t1.2 <- cont.bans.t1.2[order(cont.bans.t1.2$V1, decreasing = TRUE), ]
cont.bans.t1.3 <- ddply(data.games,.(t1_ban3),nrow)
cont.bans.t1.3 <- cont.bans.t1.3[order(cont.bans.t1.3$V1, decreasing = TRUE), ]
cont.bans.t1.4 <- ddply(data.games,.(t1_ban4),nrow)
cont.bans.t1.4 <- cont.bans.t1.4[order(cont.bans.t1.4$V1, decreasing = TRUE), ]
cont.bans.t1.5 <- ddply(data.games,.(t1_ban5),nrow)
cont.bans.t1.5 <- cont.bans.t1.5[order(cont.bans.t1.5$V1, decreasing = TRUE), ]
# TEAM 2
cont.bans.t2.1 <- ddply(data.games,.(t2_ban1),nrow)
cont.bans.t2.1 <- cont.bans.t2.1[order(cont.bans.t2.1$V1, decreasing = TRUE), ]
cont.bans.t2.2 <- ddply(data.games,.(t2_ban2),nrow)
cont.bans.t2.2 <- cont.bans.t2.2[order(cont.bans.t2.2$V1, decreasing = TRUE), ]
cont.bans.t2.3 <- ddply(data.games,.(t2_ban3),nrow)
cont.bans.t2.3 <- cont.bans.t2.3[order(cont.bans.t2.3$V1, decreasing = TRUE), ]
cont.bans.t2.4 <- ddply(data.games,.(t2_ban4),nrow)
cont.bans.t2.4 <- cont.bans.t2.4[order(cont.bans.t2.4$V1, decreasing = TRUE), ]
cont.bans.t2.5 <- ddply(data.games,.(t2_ban5),nrow)
cont.bans.t2.5 <- cont.bans.t2.5[order(cont.bans.t2.5$V1, decreasing = TRUE), ]
# Ahora lo que tengo que hacer es sumar todas estas columnas de V1 según el valor de name...
df.bans <- left_join(cont.bans.t1.1, cont.bans.t1.2, by =c("t1_ban1" = "t1_ban2"))
df.bans <- left_join(df.bans, cont.bans.t1.3, by =c("t1_ban1" = "t1_ban3"))
df.bans <- left_join(df.bans, cont.bans.t1.4, by =c("t1_ban1" = "t1_ban4"))
df.bans <- left_join(df.bans, cont.bans.t1.5, by =c("t1_ban1" = "t1_ban5"))
df.bans <- left_join(df.bans, cont.bans.t2.1, by =c("t1_ban1" = "t2_ban1"))
df.bans <- left_join(df.bans, cont.bans.t2.2, by =c("t1_ban1" = "t2_ban2"))
df.bans <- left_join(df.bans, cont.bans.t2.3, by =c("t1_ban1" = "t2_ban3"))
df.bans <- left_join(df.bans, cont.bans.t2.4, by =c("t1_ban1" = "t2_ban4"))
df.bans <- left_join(df.bans, cont.bans.t2.5, by =c("t1_ban1" = "t2_ban5"))
df.bans$total <- rowSums( df.bans[,2:11] )
remove(cont.bans.t1.1)
remove(cont.bans.t1.2)
remove(cont.bans.t1.3)
remove(cont.bans.t1.4)
remove(cont.bans.t1.5)
remove(cont.bans.t2.1)
remove(cont.bans.t2.2)
remove(cont.bans.t2.3)
remove(cont.bans.t2.4)
remove(cont.bans.t2.5)
df.bans <- df.bans[order(df.bans$total, decreasing = TRUE), ]
df.bans <- df.bans[, -2:-11]
head(df.bans)
# Finalmente, junto con la tabla de data.champs para ponerles nombre...
df.bans <- left_join(df.bans, data.champs, by=c("t1_ban1" = "id"))
df.bans <- df.bans[, -1]
head(df.bans)
set.seed(9999) # Para el mantenimiento del mismo patrón
wordcloud(words = df.bans$name, freq = df.bans$total, min.freq = 1, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))
# Ratio del más baneado
print("El porcentaje de baneo a Yasuo es de: ")
ratio.ban.yasuo <- df.bans$total[1]/sum(df.bans$total)
print(ratio.ban.yasuo)
data.dragons.win <- cbind(data.games$t1_dragonKills, data.games$t2_dragonKills, data.games$winner)
colnames(data.dragons.win) <- c("KillsT1", "KillsT2", "Win")
head(data.dragons.win)
res.dragons.win <- cor(data.dragons.win, method = "spearman")
options(width = 100)
res.dragons.win.round <- round(res.dragons.win, 2)
corrplot(res.dragons.win.round, method="square", type = "upper", tl.srt = 0.7)
mosaicplot(table(data.dragons.win[, 1], data.dragons.win[, 3]), main='Winrate por dragones matados, Equipo 1', shade=TRUE)
mosaicplot(table(data.dragons.win[, 2], data.dragons.win[, 3]), main='Winrate por dragones matados, Equipo 2', shade=TRUE)
# Lo que voy a hacer es contar por columnas, y luego sumo todas las columnas que he contado. Así obtengo el recuento final
# TEAM 1
cont.picks.t1.1 <- ddply(data.games,.(t1_champ1id),nrow)
cont.picks.t1.1 <- cont.picks.t1.1[order(cont.picks.t1.1$V1, decreasing = TRUE), ]
cont.picks.t1.2 <- ddply(data.games,.(t1_champ2id),nrow)
cont.picks.t1.2 <- cont.picks.t1.2[order(cont.picks.t1.2$V1, decreasing = TRUE), ]
cont.picks.t1.3 <- ddply(data.games,.(t1_champ3id),nrow)
cont.picks.t1.3 <- cont.picks.t1.3[order(cont.picks.t1.3$V1, decreasing = TRUE), ]
cont.picks.t1.4 <- ddply(data.games,.(t1_champ4id),nrow)
cont.picks.t1.4 <- cont.picks.t1.4[order(cont.picks.t1.4$V1, decreasing = TRUE), ]
cont.picks.t1.5 <- ddply(data.games,.(t1_champ5id),nrow)
cont.picks.t1.5 <- cont.picks.t1.5[order(cont.picks.t1.5$V1, decreasing = TRUE), ]
# TEAM 2
cont.picks.t2.1 <- ddply(data.games,.(t2_champ1id),nrow)
cont.picks.t2.1 <- cont.picks.t2.1[order(cont.picks.t2.1$V1, decreasing = TRUE), ]
cont.picks.t2.2 <- ddply(data.games,.(t2_champ2id),nrow)
cont.picks.t2.2 <- cont.picks.t2.2[order(cont.picks.t2.2$V1, decreasing = TRUE), ]
cont.picks.t2.3 <- ddply(data.games,.(t2_champ3id),nrow)
cont.picks.t2.3 <- cont.picks.t2.3[order(cont.picks.t2.3$V1, decreasing = TRUE), ]
cont.picks.t2.4 <- ddply(data.games,.(t2_champ4id),nrow)
cont.picks.t2.4 <- cont.picks.t2.4[order(cont.picks.t2.4$V1, decreasing = TRUE), ]
cont.picks.t2.5 <- ddply(data.games,.(t2_champ5id),nrow)
cont.picks.t2.5 <- cont.picks.t2.5[order(cont.picks.t2.5$V1, decreasing = TRUE), ]
# Ahora lo que tengo que hacer es sumar todas estas columnas de V1 según el valor de name...
df.picks <- left_join(cont.picks.t1.1, cont.picks.t1.2, by =c("t1_champ1id" = "t1_champ2id"))
df.picks <- left_join(df.picks, cont.picks.t1.3, by =c("t1_champ1id" = "t1_champ3id"))
df.picks <- left_join(df.picks, cont.picks.t1.4, by =c("t1_champ1id" = "t1_champ4id"))
df.picks <- left_join(df.picks, cont.picks.t1.5, by =c("t1_champ1id" = "t1_champ5id"))
df.picks <- left_join(df.picks, cont.picks.t2.1, by =c("t1_champ1id" = "t2_champ1id"))
df.picks <- left_join(df.picks, cont.picks.t2.2, by =c("t1_champ1id" = "t2_champ2id"))
df.picks <- left_join(df.picks, cont.picks.t2.3, by =c("t1_champ1id" = "t2_champ3id"))
df.picks <- left_join(df.picks, cont.picks.t2.4, by =c("t1_champ1id" = "t2_champ4id"))
df.picks <- left_join(df.picks, cont.picks.t2.5, by =c("t1_champ1id" = "t2_champ5id"))
df.picks$total <- rowSums( df.picks[,2:11] )
remove(cont.picks.t1.1)
remove(cont.picks.t1.2)
remove(cont.picks.t1.3)
remove(cont.picks.t1.4)
remove(cont.picks.t1.5)
remove(cont.picks.t2.1)
remove(cont.picks.t2.2)
remove(cont.picks.t2.3)
remove(cont.picks.t2.4)
remove(cont.picks.t2.5)
df.picks <- df.picks[order(df.picks$total, decreasing = TRUE), ]
df.picks <- df.picks[, -2:-11]
head(df.picks)
# Finalmente, junto con la tabla de data.champs para ponerles nombre...
df.picks <- left_join(df.picks, data.champs, by=c("t1_champ1id" = "id"))
df.picks <- df.picks[, -1]
head(df.picks)
set.seed(9998) # Para el mantenimiento del mismo patrón
wordcloud(words = df.picks$name, freq = df.picks$total, min.freq = 3000, random.order=FALSE,
rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))
# Ratio del más baneado
print("El porcentaje de pick de Thresh es de: ")
ratio.pick.thresh <- df.picks$total[1]/sum(df.picks$total)
print(ratio.pick.thresh)
dataframe.winners.1 <- filter(data.games, winner == "1")
# En este dataframe, solo me interesan las columnas de los campeones elegidos por el equipo 1, por lo que solo me quedo con ellas:
dataframe.winners.1 <- dataframe.winners.1[, c(12, 15, 18, 21, 24)]
colnames(dataframe.winners.1) <- c("Pick1", "Pick2", "Pick3", "Pick4", "Pick5")
# Hacemos lo mismo con los ganadores del equipo 2
dataframe.winners.2 <- filter(data.games, winner == "2")
# En este dataframe, solo me interesan las columnas de los campeones elegidos por el equipo 1, por lo que solo me quedo con ellas:
dataframe.winners.2 <- dataframe.winners.2[, c(37, 40, 43, 46, 49)]
colnames(dataframe.winners.2) <- c("Pick1", "Pick2", "Pick3", "Pick4", "Pick5")
# Ahora los juntamos...
dataframe.winners <- rbind(dataframe.winners.1, dataframe.winners.2)
remove(dataframe.winners.1)
remove(dataframe.winners.2)
# Ahora voy a llevar todas las columnas a una:
dataframe.winners <- data.frame(all = c(dataframe.winners[,"Pick1"],
dataframe.winners[,"Pick2"],
dataframe.winners[,"Pick3"],
dataframe.winners[,"Pick4"],
dataframe.winners[,"Pick5"]))
head(dataframe.winners)
dataframe.winners <- left_join(dataframe.winners, data.champs, by=c("all" = "id"))
dataframe.winners <- dataframe.winners[, -1]
head(dataframe.winners)
# Ahora tenemos todo el dataframe en una única columna, donde solo nos queda ordenar y contar el número de ocurrencias:
dataframe.winners <- dataframe.winners[order(dataframe.winners)]
head(dataframe.winners)
# Contamos
cantidad <- as.data.frame(table(dataframe.winners))
cantidad <- cantidad[order(cantidad$Freq, decreasing = TRUE), ]
colnames(cantidad) <- c("name", "freq")
head(cantidad)
# Para hacer esto, voy a juntar los dos dataframes en uno solo, juntando por el valor del campeón (nombre), y una vez hecho esto podré restar entre mismas columnas
# No puedo hacer un join normal porque todos mis elementos de texto son factors, por eso lo reconvierto
cantidad <- data.frame(cantidad, stringsAsFactors = FALSE)
colnames(cantidad) <- c("name", "freq_win")
df.picks <- data.frame(df.picks, stringsAsFactors = FALSE)
colnames(df.picks) <- c("total_picks", "name")
dataframe.pick.win <- inner_join(cantidad, df.picks, by="name")
# Ahora que tengo los datos a mano, podemos hacer las divisiones:
dataframe.pick.win <- transform(dataframe.pick.win, ratio = dataframe.pick.win[, 2] / dataframe.pick.win[, 3])
dataframe.pick.win <- dataframe.pick.win[order(dataframe.pick.win$ratio, decreasing = TRUE), ]
head(dataframe.pick.win)
columna.wins <- data.games$winner
cantidad.wins <- as.data.frame(table(columna.wins))
colnames(cantidad.wins) <- c("winner", "frequency")
head(cantidad.wins)
# Si calculamos el ratio...
ratio.red <- cantidad.wins[2, 2] / (cantidad.wins[1, 2] + cantidad.wins[2, 2])
ratio.red
ratio.blue <- cantidad.wins[1, 2] / (cantidad.wins[1, 2] + cantidad.wins[2, 2])
ratio.blue
ratios_win <- c(ratio.blue, ratio.red)
barplot(ratios_win, main="Victorias por equipo", ylab="Equipo", col = c("Blue", "Red"))
# Los datos de esto los tenemos en data.games. Para aclarar, vamos a hacer un dataset específico con los datos de los objetivos...
data.first.objectives <- data.games[, 6:11]
# Es importante remarcar que aquí hay 3 valores: 0 si nadie lo ha conseguido, 1 si lo ha conseguido el equipo azul y 2 si lo ha conseguido el equipo rojo.
head(data.first.objectives)
# Ahora mi objetivo es contar de cada una de las líneas lo que hay, y de aquí sacar conclusiones:
firstblood.qty <- as.data.frame(table(data.first.objectives[, 1]))
firsttower.qty <- as.data.frame(table(data.first.objectives[, 2]))
firstinhib.qty <- as.data.frame(table(data.first.objectives[, 3]))
firstbaron.qty <- as.data.frame(table(data.first.objectives[, 4]))
firstdragon.qty <- as.data.frame(table(data.first.objectives[, 5]))
firstherald.qty <- as.data.frame(table(data.first.objectives[, 6]))
# Ahora lo vemos bien en barplots...
array.firstblood <- c(firstblood.qty[1, 2],firstblood.qty[2, 2], firstblood.qty[3, 2])
barplot(array.firstblood, main="Partidas en las que los equipos hicieron Primera sangre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstblood.qty$Var1)
array.firsttower <- c(firsttower.qty[1, 2],firsttower.qty[2, 2], firsttower.qty[3, 2])
barplot(array.firsttower, main="Partidas en las que los equipos hicieron Primera torre", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firsttower.qty$Var1)
array.firstinhib <- c(firstinhib.qty[1, 2],firstinhib.qty[2, 2], firstinhib.qty[3, 2])
barplot(array.firstinhib, main="Partidas en las que los equipos hicieron primer inhibidor", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstinhib.qty$Var1)
array.firstbaron <- c(firstbaron.qty[1, 2],firstbaron.qty[2, 2], firstbaron.qty[3, 2])
barplot(array.firstbaron, main="Partidas en las que los equipos hicieron primer barón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstbaron.qty$Var1)
array.firstdragon <- c(firstdragon.qty[1, 2],firstdragon.qty[2, 2], firstdragon.qty[3, 2])
barplot(array.firstdragon, main="Partidas en las que los equipos hicieron primer dragón", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstdragon.qty$Var1)
array.firstherald <- c(firstherald.qty[1, 2],firstherald.qty[2, 2], firstherald.qty[3, 2])
barplot(array.firstherald, main="Partidas en las que los equipos hicieron el heraldo", xlab="Equipo / Ninguno", ylab = "Número de partidas",
ylim = c(0,30000), col = c("White", "Blue", "Red"), legend.text=firstherald.qty$Var1)
dataframe.firstObjective <- cbind(array.firstblood, array.firsttower, array.firstdragon, array.firstherald, array.firstinhib, array.firstbaron)
colnames(dataframe.firstObjective) <- c('FirstBlood', 'FirstTower', 'FirstDragon', 'FirstHerald', 'FirstInhib', 'FirstBaron')
colours = c("white","blue","red")
barplot(dataframe.firstObjective, main='Cantidad de primer objetivo de cada tipo conseguido por los equipos',ylab='Veces', xlab='Evento',beside = TRUE,
col=colours, ylim=c(0,max(dataframe.firstObjective)*1.3))
# to add a box around the plot
box()
#data.games.factors <- lapply(data.games, function(x){as.factor(x)})
#reglas <- apriori(data.games.factors, parameter = list(support = 0.01, confidence = 0.5))
data.games.names <- inner_join(data.games, data.champs, by = c("t1_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t1_champ5id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ1id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ2id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ3id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ4id" = "id"))
data.games.names <- inner_join(data.games.names, data.champs, by = c("t2_champ5id" = "id"))
champs.names <- data.games.names[,62:71]
colnames(champs.names) <- c("P1T1", "P2T1", "P3T1", "P4T1", "P5T1", "P1T2", "P2T2", "P3T2", "P4T2", "P5T2")
# Ahora paso todos los campeones a variables binarias. Esto hace que para todas las predicciones no tenga que usar distancias ni categorías entre ellos, lo que me permite que sean más justas.
vectors_champs <- dummy_cols(champs.names)
vectors_champs <- vectors_champs[, -1:-10]
# Ahora lo único que tengo que hacer es crear el dataset final para el machine learning, quitando aquellas variables que no deseo que estén (entre ellas el código de los campeones) y añadiendo esta codificación binaria que acabo de crear.
data.ml <- data.games[, c(-1, -2, -4, -13, -14, -16, -17, -19, -20, -22, -23, -25, -26, -38, -39, -41, -42, -44, -45, -47, -48)]
data.ml <- data.ml[, -9:-13]
data.ml <- data.ml[, -19:-25]
# Ahora hago lo mismo de antes para los nombres pero con los bans. Antes que nada, tengo que añadir None como la elección de ningún campeón para banear en el df de campeones.
df.tonto <- data.frame("None", as.integer(1000))
names(df.tonto) <- c("name", "id")
data.champs <- rbind(data.champs, df.tonto)
data.games[data.games=="-1"]<-1000
data.games.bans <- inner_join(data.games, data.champs, by = c("t1_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t1_ban5" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban1" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban2" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban3" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban4" = "id"))
data.games.bans <- inner_join(data.games.bans, data.champs, by = c("t2_ban5" = "id"))
champs.bans.names <- data.games.bans[,62:71]
colnames(champs.bans.names) <- c("B1T1", "B2T1", "B3T1", "B4T1", "B5T1", "B1T2", "B2T2", "B3T2", "B4T2", "B5T2")
vectors_champs.bans <- dummy_cols(champs.bans.names)
vectors_champs.bans <- vectors_champs.bans[, -1:-10]
# Finalmente, hago las últimas transformaciones y adiciones a data.ml para obtener el resultado final
data.ml <- data.ml[, -14:-18]
data.ml <- data.ml[, -19:-23]
data.ml <- cbind(data.ml, vectors_champs, vectors_champs.bans)
# Ahora tenemos todo junto. Limpio los df que han quedado como auxiliares y procedemos al centrado y escalado:
remove(vectors_champs.bans)
remove(vectors_champs)
remove(df.tonto)
# Finalmente, ver el head del dataframe es demasiado, de tal manera que vamos a ver los nombres de las columnas:
colnames( data.ml[2000:2500] )
library("caret")
colnames( data.ml[1:10] )
data.ml.centscal <- data.ml[, -2]
preObjeto <- preProcess(data.ml.centscal, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
data.ml.centscal <- predict(preObjeto, data.ml.centscal)
object_size(data.ml.centscal)
object_size(data.ml)
head(data.ml.centscal[, 1:10])
head(data.ml.centscal[, 1:20])
View(data.champs)
View(data.champs)
View(data.games.names)
View(data.games.names)
object_size(data.ml)
object_size(data.ml.centscal)
head(data.ml.centscal[, 1:20])
library("nnet")
conjuntoEntrenamiento <- sample(1:51490, 45000)
partidas.1neu <- nnet( data.ml.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1 )
partidas.1neu <- nnet( data.ml.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1, MaxNWts=10000000 )
partidas.prediccion.1neu <- predict( partidas.1neu, data.ml.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.1neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.1neu.class <- apply( partidas.prediccion.1neu, MARGIN=1, FUN='which.is.max')
partidas.prediccion.1neu.class
# Lo visualizo en forma de tabla para ir viendo el error
table( partidas.prediccion.1neu.class, data.ml[conjuntoEntrenamiento, 2] )  # Lo vemos en forma de tabla.
#Calculo el acierto
sum( diag( table( partidas.prediccion.1neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/45000 # Esta cuenta nos da el índice de acierto
partidas.prediccion.test.1neu <- predict( partidas.1neu, data.ml.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.1neu
partidas.prediccion.test.1neu.class <- apply( partidas.prediccion.test.1neu, MARGIN=1, FUN='which.is.max')
partidas.prediccion.test.1neu.class
table( partidas.prediccion.test.1neu.class , data.ml[-conjuntoEntrenamiento, 2] )
sum( diag( table( partidas.prediccion.test.1neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(51490-45000)
partidas.1neu <- nnet( data.ml.centscal[conjuntoEntrenamiento, ], class.ind( data.ml[conjuntoEntrenamiento, 2] ) , size=1, MaxNWts=10000000 )
#Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
partidas.prediccion.1neu <- predict( partidas.1neu, data.ml.centscal[conjuntoEntrenamiento, ], type="raw" )
head(partidas.prediccion.1neu) # Vemos las probabilidades de pertenencia de cada valor
# Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
partidas.prediccion.1neu.class <- apply( partidas.prediccion.1neu, MARGIN=1, FUN='which.is.max')
# Lo visualizo en forma de tabla para ir viendo el error
table( partidas.prediccion.1neu.class, data.ml[conjuntoEntrenamiento, 2] )  # Lo vemos en forma de tabla.
#Calculo el acierto
sum( diag( table( partidas.prediccion.1neu.class, data.ml[conjuntoEntrenamiento, 2] ) ) )/45000 # Esta cuenta nos da el índice de acierto
partidas.prediccion.test.1neu <- predict( partidas.1neu, data.ml.centscal[-conjuntoEntrenamiento, ], type="raw" )
partidas.prediccion.test.1neu.class <- apply( partidas.prediccion.test.1neu, MARGIN=1, FUN='which.is.max')
table( partidas.prediccion.test.1neu.class , data.ml[-conjuntoEntrenamiento, 2] )
sum( diag( table( partidas.prediccion.test.1neu.class, data.ml[-conjuntoEntrenamiento, 2] ) ) )/(51490-45000)
size(conjuntoEntrenamiento)
length(conjuntoEntrenamiento)
length(data.ml.centscal)
size(data.ml.centscal)
nrow(data.ml.centscal)
conjuntoEntrenamiento <- sample(1:nrow(data.ml.centscal), 45000)
